diff --git a/src/features/AppointmentsScheduler/AppointmentsScheduler.tsx b/src/features/AppointmentsScheduler/AppointmentsScheduler.tsx
index fd8bbf4..8016e86 100644
--- a/src/features/AppointmentsScheduler/AppointmentsScheduler.tsx
+++ b/src/features/AppointmentsScheduler/AppointmentsScheduler.tsx
@@ -11,21 +11,28 @@ import {
   KendoSchedulerView,
   PageHeader,
 } from './components';
+import { useFirstAvailableDateTime } from './hooks/useFirstAvailableDateTime';
+import { schedulerScrollTo } from './components/KendoSchedulerView/utils';
 
 const { Content } = Layout;
 
 export const AppointmentsScheduler = () => {
   const [selectedSlotDate, setSelectedSlotDate] = useState<Date | null>(null);
-
   const [isSameDay, setIsSameDay] = useState<boolean>(false);
-
   const [showFilters, setShowFilters] = useState<boolean>(true);
   const [showSidebar, setShowSidebar] = useState<boolean>(false);
-
   const [appointmentQuantity, setAppointmentQuantity] = useState<number | null>(
     null
   );
 
+  // Hook para datos del primer turno disponible
+  const {
+    dateObject: firstAvailableDate,
+    hasData: hasFirstAvailableData,
+    timeSlot: normalizedTimeSlot, // Horario normalizado para scroll
+    originalTimeSlot: originalTimeSlot, // Horario original para mostrar
+  } = useFirstAvailableDateTime();
+
   const handleFiltersApplied = () => {
     setSelectedSlotDate(null);
     handleCloseSidebar();
@@ -50,6 +57,47 @@ export const AppointmentsScheduler = () => {
     [selectedSlotDate]
   );
 
+  /**
+   *callback para navegar al primer turno disponible desde el icono
+   *
+   */
+  const handleNavigateToFirstAvailable = useCallback(() => {
+    if (!firstAvailableDate || !hasFirstAvailableData) {
+      showError('No hay primer turno disponible para navegar');
+      return;
+    }
+
+    console.log('=== NAVEGACI√ìN DIRECTA INICIADA ===');
+    console.log('üìä Datos de navegaci√≥n:');
+    console.log('- Fecha objetivo:', firstAvailableDate);
+    console.log('- Horario original (backend):', originalTimeSlot);
+    console.log('- Horario normalizado (scroll):', normalizedTimeSlot);
+
+    // Actualizar la fecha como antes
+    if (!selectedSlotDate) {
+      setIsSameDay(false);
+      setSelectedSlotDate(firstAvailableDate);
+    } else {
+      setIsSameDay(checkIsSameDay(selectedSlotDate, firstAvailableDate));
+      setSelectedSlotDate(firstAvailableDate);
+    }
+
+    // SCROLL DIRECTO usando horario NORMALIZADO
+    setTimeout(() => {
+      console.log('=== SCROLL DIRECTO DESDE CALLBACK ===');
+      console.log(
+        'üéØ Ejecutando scroll a horario normalizado:',
+        normalizedTimeSlot
+      );
+      schedulerScrollTo(normalizedTimeSlot);
+    }, 400);
+  }, [
+    firstAvailableDate,
+    hasFirstAvailableData,
+    normalizedTimeSlot,
+    originalTimeSlot,
+    selectedSlotDate,
+  ]);
   const handleToggleShowFilters = () => {
     setShowFilters((current) => !current);
   };
@@ -95,6 +143,7 @@ export const AppointmentsScheduler = () => {
             <PageHeader
               showFilters={showFilters}
               handleToggleShowFilters={handleToggleShowFilters}
+              onNavigateToFirstAvailable={handleNavigateToFirstAvailable}
             />
             <div className={styles['scheduler-body']}>
               <KendoSchedulerView
diff --git a/src/features/AppointmentsScheduler/components/KendoSchedulerView/KendoSchedulerView.tsx b/src/features/AppointmentsScheduler/components/KendoSchedulerView/KendoSchedulerView.tsx
index 1a85e0b..003052e 100644
--- a/src/features/AppointmentsScheduler/components/KendoSchedulerView/KendoSchedulerView.tsx
+++ b/src/features/AppointmentsScheduler/components/KendoSchedulerView/KendoSchedulerView.tsx
@@ -18,7 +18,7 @@ import {
   schedulerScrollTo,
   WORK_DAY_START,
   WORK_DAY_END,
-  WORK_START_TIME,
+  // WORK_START_TIME,
   SLOT_DURATION,
   SLOT_DIVISION,
   FROM_DATE_COMPRESSED_FORMAT,
@@ -28,6 +28,7 @@ import styles from './styles/KendoSchedulerView.module.css';
 import { SchedulerViewType } from '~/features/AppointmentsScheduler/types/scheduler.types';
 import { SCHEDULER_VIEW } from '~/features/AppointmentsScheduler/utils';
 import { useFirstAvailableAppointmentsSummaryData } from '~/features/AppointmentsScheduler/hooks';
+import { useFirstAvailableTimeSlot } from './hooks/useFirstAvailableTimeSlot';
 
 const COMPRESSED_DATE_FORMAT = `${FROM_DATE_COMPRESSED_FORMAT} - ${TO_DATE_COMPRESSED_FORMAT}`;
 
@@ -50,7 +51,7 @@ export const KendoSchedulerView: React.FC<Props> = ({
   const ofertaResumidaMensual = useAppointmentsSummaryStore(
     (state) => state?.ofertaResumidaMensual
   );
-
+  const firstAvailableTimeSlot = useFirstAvailableTimeSlot();
   const { firstAvailableDay } = useFirstAvailableAppointmentsSummaryData();
 
   const {
@@ -76,8 +77,64 @@ export const KendoSchedulerView: React.FC<Props> = ({
   }, [error, isBeforeTodayError]);
 
   useEffect(() => {
-    schedulerScrollTo(WORK_START_TIME);
-  }, [selectedView]);
+    console.log('=== SCROLL INICIAL MEJORADO ===');
+    console.log('selectedView:', selectedView);
+    console.log('firstAvailableTimeSlot completo:', firstAvailableTimeSlot);
+
+    if (firstAvailableTimeSlot.hasRealData) {
+      console.log('üìä Datos de scroll:');
+      console.log(
+        '- Horario normalizado (para scroll):',
+        firstAvailableTimeSlot.timeSlot
+      );
+      console.log(
+        '- Horario original (backend):',
+        firstAvailableTimeSlot.originalTimeSlot
+      );
+      console.log('- Fuente de datos:', firstAvailableTimeSlot.source);
+
+      const timer = setTimeout(() => {
+        console.log(
+          'üéØ Ejecutando scroll a horario normalizado:',
+          firstAvailableTimeSlot.timeSlot
+        );
+        schedulerScrollTo(firstAvailableTimeSlot.timeSlot);
+      }, 300);
+
+      return () => clearTimeout(timer);
+    } else {
+      console.log('‚è≥ Sin datos reales a√∫n, esperando...');
+      console.log('- isLoading:', firstAvailableTimeSlot.isLoading);
+      console.log('- timeSlot fallback:', firstAvailableTimeSlot.timeSlot);
+    }
+  }, [
+    selectedView,
+    firstAvailableTimeSlot.timeSlot,
+    firstAvailableTimeSlot.hasRealData,
+    firstAvailableTimeSlot.originalTimeSlot,
+  ]);
+
+  // // ‚úÖ SCROLL PARA NAVEGACI√ìN DESDE ICONO
+  // useEffect(() => {
+  //   console.log('=== NAVEGACI√ìN DESDE ICONO ===');
+
+  //   // Detectar si selectedDate cambi√≥ a firstAvailableDay
+  //   if (
+  //     selectedDate &&
+  //     firstAvailableDay &&
+  //     selectedDate.getTime() === firstAvailableDay.getTime() &&
+  //     firstAvailableTimeSlot.hasRealData
+  //   ) {
+  //     console.log('Navegaci√≥n desde icono detectada');
+  //     console.log('Scroll a horario:', firstAvailableTimeSlot.timeSlot);
+
+  //     const timer = setTimeout(() => {
+  //       schedulerScrollTo(firstAvailableTimeSlot.timeSlot);
+  //     }, 200);
+
+  //     return () => clearTimeout(timer);
+  //   }
+  // }, [selectedDate, firstAvailableDay, firstAvailableTimeSlot.timeSlot, firstAvailableTimeSlot.hasRealData]);
 
   const handleViewChange = (e: SchedulerViewChangeEvent) => {
     if (e?.value === SCHEDULER_VIEW.MONTH) {
diff --git a/src/features/AppointmentsScheduler/components/KendoSchedulerView/components/SlotAppointmentQuantity/SlotAppointmentQuantity.module.css b/src/features/AppointmentsScheduler/components/KendoSchedulerView/components/SlotAppointmentQuantity/SlotAppointmentQuantity.module.css
index 32420cd..ae683a7 100644
--- a/src/features/AppointmentsScheduler/components/KendoSchedulerView/components/SlotAppointmentQuantity/SlotAppointmentQuantity.module.css
+++ b/src/features/AppointmentsScheduler/components/KendoSchedulerView/components/SlotAppointmentQuantity/SlotAppointmentQuantity.module.css
@@ -6,7 +6,7 @@
   font-size: 14px;
   font-weight: 500;
   text-align: center;
-  white-space: nowrap;
+  white-space: normal;
   pointer-events: none;
   z-index: 1;
   font-weight: 600;
diff --git a/src/features/AppointmentsScheduler/components/KendoSchedulerView/hooks/useFirstAvailableTimeSlot.ts b/src/features/AppointmentsScheduler/components/KendoSchedulerView/hooks/useFirstAvailableTimeSlot.ts
new file mode 100644
index 0000000..41303e1
--- /dev/null
+++ b/src/features/AppointmentsScheduler/components/KendoSchedulerView/hooks/useFirstAvailableTimeSlot.ts
@@ -0,0 +1,99 @@
+import { useMemo } from 'react';
+import { useAppointmentsSummaryStore } from '~/features/AppointmentsScheduler/store';
+import { WORK_START_TIME, normalizeTimeToSchedulerSlot } from '../utils';
+
+/**
+ * Hook para obtener el primer horario disponible de turnos
+ * Normaliza el horario espec√≠fico al slot correspondiente del scheduler
+ */
+export const useFirstAvailableTimeSlot = () => {
+  const primerOfertaDisponible = useAppointmentsSummaryStore(
+    (state) => state?.primerOfertaDisponible
+  );
+  const ofertaResumidaDiaria = useAppointmentsSummaryStore(
+    (state) => state?.ofertaResumidaDiaria
+  );
+
+  return useMemo(() => {
+    // Estado de carga: Si no hay primerOfertaDisponible ni ofertaResumidaDiaria
+    const isLoading = !primerOfertaDisponible && !ofertaResumidaDiaria?.length;
+
+    // Estrategia 1: Usar primerOfertaDisponible (m√°s preciso)
+    if (primerOfertaDisponible) {
+      try {
+        const date = new Date(primerOfertaDisponible);
+
+        if (!isNaN(date.getTime())) {
+          const specificTimeString = date.toLocaleTimeString('es-ES', {
+            hour: '2-digit',
+            minute: '2-digit',
+            hour12: false,
+          });
+
+          // NORMALIZAR al slot del scheduler
+          const normalizedTimeSlot =
+            normalizeTimeToSchedulerSlot(specificTimeString);
+
+          // Validar formato de hora normalizada (HH:MM)
+          if (/^\d{2}:\d{2}$/.test(normalizedTimeSlot)) {
+            return {
+              timeSlot: normalizedTimeSlot, // Slot normalizado para scroll
+              originalTimeSlot: specificTimeString, // Horario original del backend
+              source: 'primerOfertaDisponible',
+              isLoading: false,
+              hasRealData: true,
+            };
+          }
+        }
+      } catch (error) {
+        console.warn('Error parsing primerOfertaDisponible:', error);
+      }
+    }
+
+    // Estrategia 2: Fallback usando ofertaResumidaDiaria
+    if (ofertaResumidaDiaria?.length) {
+      try {
+        const firstAvailable = ofertaResumidaDiaria.find(
+          (oferta) => oferta.totalTurnosDisponibles > 0
+        );
+
+        if (firstAvailable?.horaInicio) {
+          const date = new Date(firstAvailable.horaInicio);
+
+          if (!isNaN(date.getTime())) {
+            const specificTimeString = date.toLocaleTimeString('es-ES', {
+              hour: '2-digit',
+              minute: '2-digit',
+              hour12: false,
+            });
+
+            // NORMALIZAR al slot del scheduler
+            const normalizedTimeSlot =
+              normalizeTimeToSchedulerSlot(specificTimeString);
+
+            if (/^\d{2}:\d{2}$/.test(normalizedTimeSlot)) {
+              return {
+                timeSlot: normalizedTimeSlot, // Slot normalizado para scroll
+                originalTimeSlot: specificTimeString, // Horario original
+                source: 'ofertaResumidaDiaria',
+                isLoading: false,
+                hasRealData: true,
+              };
+            }
+          }
+        }
+      } catch (error) {
+        console.warn('Error parsing ofertaResumidaDiaria horaInicio:', error);
+      }
+    }
+
+    // Estrategia 3: Fallback a WORK_START_TIME
+    return {
+      timeSlot: WORK_START_TIME,
+      originalTimeSlot: WORK_START_TIME,
+      source: 'fallback',
+      isLoading,
+      hasRealData: false,
+    };
+  }, [primerOfertaDisponible, ofertaResumidaDiaria]);
+};
diff --git a/src/features/AppointmentsScheduler/components/KendoSchedulerView/utils/index.ts b/src/features/AppointmentsScheduler/components/KendoSchedulerView/utils/index.ts
index beb31f8..4540e61 100644
--- a/src/features/AppointmentsScheduler/components/KendoSchedulerView/utils/index.ts
+++ b/src/features/AppointmentsScheduler/components/KendoSchedulerView/utils/index.ts
@@ -2,3 +2,4 @@ export { formatDate } from './formatDate';
 export { schedulerScrollTo } from './schedulerScrollTo';
 export * from './schedulerViewDateRange';
 export * from './constants';
+export * from './timeSlotNormalizer';
diff --git a/src/features/AppointmentsScheduler/components/KendoSchedulerView/utils/schedulerScrollTo.ts b/src/features/AppointmentsScheduler/components/KendoSchedulerView/utils/schedulerScrollTo.ts
index cfb90f1..2046adf 100644
--- a/src/features/AppointmentsScheduler/components/KendoSchedulerView/utils/schedulerScrollTo.ts
+++ b/src/features/AppointmentsScheduler/components/KendoSchedulerView/utils/schedulerScrollTo.ts
@@ -1,14 +1,233 @@
+import { getTimeSlotVariants } from './timeSlotNormalizer';
+
+/**
+ * Funci√≥n mejorada para hacer scroll a un horario espec√≠fico en el scheduler
+ * Usa m√∫ltiples variantes de b√∫squeda y estrategias robustas
+ */
 export const schedulerScrollTo = (timeSlot: string) => {
+  console.log('=== SCHEDULER SCROLL TO V2 ===');
+  console.log('Horario objetivo:', timeSlot);
+
+  // Estrategia 1: Buscar el contenedor principal del scheduler
   const schedulerContentElement = document.querySelector(
     'div.k-scheduler-body'
   );
-  if (!schedulerContentElement) return;
 
-  const targetDiv = [
-    ...schedulerContentElement?.querySelectorAll('div.k-scheduler-cell'),
-  ]?.find((div: any) => div?.textContent?.trim() === timeSlot);
+  if (!schedulerContentElement) {
+    console.warn('No se encontr√≥ div.k-scheduler-body');
+    return;
+  }
+
+  console.log('Scheduler body encontrado:', schedulerContentElement);
+
+  // Obtener variantes del horario para mejorar las chances de encontrarlo
+  const timeSlotVariants = getTimeSlotVariants(timeSlot);
+
+  let targetElement: Element | null = null;
+
+  // Estrategia 2: Buscar usando variantes espec√≠ficas del horario
+  for (const variant of timeSlotVariants) {
+    console.log('Probando variante:', variant);
+
+    // Selectores espec√≠ficos de Kendo Scheduler para celdas de tiempo
+    const kendoTimeSelectors = [
+      // Selectores para vista semanal - celdas de tiempo lateral
+      `div.k-scheduler-times .k-scheduler-cell[data-time="${variant}"]`,
+      `div.k-scheduler-times .k-scheduler-cell[data-time*="${variant}"]`,
+      `td.k-scheduler-times-cell[data-time="${variant}"]`,
+      `div.k-heading-cell[data-time*="${variant}"]`,
+
+      // Selectores por contenido de texto
+      `div.k-scheduler-times div:contains("${variant}")`,
+      `div.k-scheduler-cell:contains("${variant}")`,
+      `td:contains("${variant}")`,
+
+      // Selectores m√°s espec√≠ficos para Kendo
+      `.k-scheduler-times .k-side-cell:contains("${variant}")`,
+      `.k-heading-cell:contains("${variant}")`,
+    ];
+
+    for (const selector of kendoTimeSelectors) {
+      try {
+        // Para selectores que usan :contains(), usar b√∫squeda manual
+        if (selector.includes(':contains(')) {
+          const baseSelector = selector.split(':contains(')[0];
+          const elements =
+            schedulerContentElement.querySelectorAll(baseSelector);
+
+          targetElement =
+            Array.from(elements).find((el: Element) => {
+              const text = el.textContent?.trim();
+              return text === variant || text?.includes(variant);
+            }) || null;
+        } else {
+          targetElement = schedulerContentElement.querySelector(selector);
+        }
+
+        if (targetElement) {
+          console.log('‚úÖ Elemento encontrado con variante:', variant);
+          console.log('Selector usado:', selector);
+          console.log('Elemento:', targetElement);
+          break;
+        }
+      } catch (error) {
+        console.warn('Error con selector:', selector, error);
+      }
+    }
+
+    if (targetElement) break; // Salir del loop de variantes si encontramos algo
+  }
+
+  // Estrategia 3: B√∫squeda manual exhaustiva si no encontramos con selectores
+  if (!targetElement) {
+    console.log('Iniciando b√∫squeda manual exhaustiva...');
+
+    // Buscar en diferentes tipos de elementos que podr√≠an contener horarios
+    const potentialContainers = [
+      ...schedulerContentElement.querySelectorAll('div.k-scheduler-times *'),
+      ...schedulerContentElement.querySelectorAll('div.k-scheduler-cell'),
+      ...schedulerContentElement.querySelectorAll('td'),
+      ...schedulerContentElement.querySelectorAll('.k-heading-cell'),
+      ...schedulerContentElement.querySelectorAll('.k-side-cell'),
+      ...schedulerContentElement.querySelectorAll('*[class*="time"]'),
+      ...schedulerContentElement.querySelectorAll('*[data-time]'),
+    ];
+
+    console.log(
+      'Elementos a revisar en b√∫squeda manual:',
+      potentialContainers.length
+    );
+
+    // Buscar coincidencias con cualquier variante
+    for (const variant of timeSlotVariants) {
+      targetElement =
+        Array.from(potentialContainers).find((element: Element) => {
+          const text = element.textContent?.trim();
+          const dataTime = element.getAttribute('data-time');
+
+          // Revisar texto visible
+          const textMatch = text === variant || text?.includes(variant);
+
+          // Revisar atributo data-time
+          const dataTimeMatch =
+            dataTime === variant || dataTime?.includes(variant);
+
+          if (textMatch || dataTimeMatch) {
+            console.log('Coincidencia manual encontrada:');
+            console.log('- Elemento:', element);
+            console.log('- Texto:', text);
+            console.log('- Data-time:', dataTime);
+            console.log('- Variante coincidente:', variant);
+            return true;
+          }
+
+          return false;
+        }) || null;
+
+      if (targetElement) break;
+    }
+  }
+
+  // Estrategia 4: B√∫squeda por posici√≥n aproximada (fallback)
+  if (!targetElement) {
+    console.log('B√∫squeda por posici√≥n aproximada...');
+
+    // Usar la primera variante (m√°s espec√≠fica) para calcular posici√≥n
+    const mainTimeSlot = timeSlotVariants[0];
+    const timeParts = mainTimeSlot.match(/^(\d{1,2}):(\d{2})$/);
+
+    if (timeParts) {
+      const targetHours = parseInt(timeParts[1], 10);
+      const targetMinutes = parseInt(timeParts[2], 10);
+      const targetTotalMinutes = targetHours * 60 + targetMinutes;
+
+      // Buscar elementos con horarios cercanos
+      const timeElements = schedulerContentElement.querySelectorAll(
+        'div.k-scheduler-times *, div[class*="time"] *, td, .k-heading-cell, .k-side-cell'
+      );
+
+      let closestElement: Element | null = null;
+      let closestDifference = Infinity;
+
+      timeElements.forEach((element: Element) => {
+        const text = element.textContent?.trim();
+        const timeMatch = text?.match(/^(\d{1,2}):(\d{2})$/);
+
+        if (timeMatch) {
+          const elementHours = parseInt(timeMatch[1], 10);
+          const elementMinutes = parseInt(timeMatch[2], 10);
+          const elementTotalMinutes = elementHours * 60 + elementMinutes;
+          const difference = Math.abs(targetTotalMinutes - elementTotalMinutes);
+
+          if (difference < closestDifference) {
+            closestDifference = difference;
+            closestElement = element;
+            console.log(
+              `Candidato cercano: ${text} (diferencia: ${difference} minutos)`
+            );
+          }
+        }
+      });
+
+      // Aceptar si est√° dentro de 2 horas (120 minutos)
+      if (closestElement && closestDifference <= 120) {
+        targetElement = closestElement;
+        console.log('‚úÖ Elemento m√°s cercano seleccionado:', targetElement);
+        console.log('Diferencia:', closestDifference, 'minutos');
+      }
+    }
+  }
+
+  // Ejecutar el scroll si encontramos un elemento
+  if (targetElement) {
+    console.log('üéØ Ejecutando scroll al elemento:', targetElement);
+
+    // Scroll principal
+    targetElement.scrollIntoView({
+      behavior: 'smooth',
+      block: 'center',
+      inline: 'nearest',
+    });
+
+    // Scroll adicional en contenedor si es necesario
+    const scrollContainer = targetElement.closest(
+      '.k-scheduler-content, .k-scheduler-body, .k-scheduler-pane'
+    );
+    if (scrollContainer) {
+      const elementRect = targetElement.getBoundingClientRect();
+      const containerRect = scrollContainer.getBoundingClientRect();
+      const offset = elementRect.top - containerRect.top - 150; // 150px de margen
+
+      if (Math.abs(offset) > 50) {
+        console.log('Ajuste de scroll adicional:', offset);
+        scrollContainer.scrollBy({
+          top: offset,
+          behavior: 'smooth',
+        });
+      }
+    }
+
+    console.log('‚úÖ Scroll ejecutado exitosamente');
+  } else {
+    console.warn(
+      '‚ùå No se pudo encontrar elemento para ninguna variante del horario:',
+      timeSlotVariants
+    );
+
+    // Debug: mostrar estructura del scheduler para diagnosticar
+    console.log('üîç Debug de estructura del scheduler:');
+    const debugElements = schedulerContentElement.querySelectorAll(
+      '*[class*="time"], *[data-time], .k-heading-cell, .k-side-cell'
+    );
+    const timeElementsInfo = Array.from(debugElements)
+      .slice(0, 10)
+      .map((el) => ({
+        tag: el.tagName,
+        classes: el.className,
+        text: el.textContent?.trim().substring(0, 20),
+        dataTime: el.getAttribute('data-time'),
+      }));
 
-  targetDiv?.scrollIntoView({
-    behavior: 'smooth',
-  });
+    console.table(timeElementsInfo);
+  }
 };
diff --git a/src/features/AppointmentsScheduler/components/KendoSchedulerView/utils/timeSlotNormalizer.ts b/src/features/AppointmentsScheduler/components/KendoSchedulerView/utils/timeSlotNormalizer.ts
new file mode 100644
index 0000000..a1ccc34
--- /dev/null
+++ b/src/features/AppointmentsScheduler/components/KendoSchedulerView/utils/timeSlotNormalizer.ts
@@ -0,0 +1,84 @@
+/**
+ * Utilitarios para normalizar horarios espec√≠ficos a slots del scheduler
+ */
+
+/**
+ * Convierte un horario espec√≠fico (ej: "20:14") al slot m√°s cercano del scheduler (ej: "20:00")
+ * Basado en la configuraci√≥n del scheduler: SLOT_DURATION = 60 minutos
+ */
+export const normalizeTimeToSchedulerSlot = (timeString: string): string => {
+  try {
+    console.log('=== NORMALIZACI√ìN DE HORARIO ===');
+    console.log('Horario original:', timeString);
+
+    // Extraer horas y minutos
+    const [hoursStr, minutesStr] = timeString.split(':');
+    const hours = parseInt(hoursStr, 10);
+    const minutes = parseInt(minutesStr, 10);
+
+    console.log('Horas:', hours, 'Minutos:', minutes);
+
+    // Validar formato
+    if (
+      isNaN(hours) ||
+      isNaN(minutes) ||
+      hours < 0 ||
+      hours > 23 ||
+      minutes < 0 ||
+      minutes > 59
+    ) {
+      console.warn('Formato de hora inv√°lido:', timeString);
+      return timeString; // Retornar original si no es v√°lido
+    }
+
+    // Para slots de 1 hora, siempre usar :00
+    // Si necesit√°ramos slots de 30 min, ser√≠a: minutes < 30 ? 0 : 30
+    const normalizedMinutes = 0;
+
+    // Formatear resultado
+    const normalizedTime = `${hours.toString().padStart(2, '0')}:${normalizedMinutes.toString().padStart(2, '0')}`;
+
+    console.log('Horario normalizado:', normalizedTime);
+    console.log('=== FIN NORMALIZACI√ìN ===');
+
+    return normalizedTime;
+  } catch (error) {
+    console.error('Error normalizando horario:', error);
+    return timeString; // Retornar original en caso de error
+  }
+};
+
+/**
+ * Busca los slots de tiempo m√°s cercanos para mejorar las chances de encontrar el elemento
+ */
+export const getTimeSlotVariants = (timeString: string): string[] => {
+  const normalizedTime = normalizeTimeToSchedulerSlot(timeString);
+  const [hoursStr] = normalizedTime.split(':');
+  const hours = parseInt(hoursStr, 10);
+
+  // Generar variantes posibles
+  const variants = [
+    normalizedTime, // "20:00"
+    `${hours}:00`, // "20:00" (sin padding)
+    `${hoursStr}:00`, // "20:00" (con padding original)
+    `${hours.toString().padStart(2, '0')}`, // "20" (solo hora)
+    `${hours}`, // "20" (hora sin padding)
+  ];
+
+  // Agregar variantes de horas adyacentes (¬±1 hora) como fallback
+  if (hours > 0) {
+    const prevHour = hours - 1;
+    variants.push(`${prevHour.toString().padStart(2, '0')}:00`);
+  }
+  if (hours < 23) {
+    const nextHour = hours + 1;
+    variants.push(`${nextHour.toString().padStart(2, '0')}:00`);
+  }
+
+  // Remover duplicados manteniendo orden
+  const uniqueVariants = [...new Set(variants)];
+
+  console.log('Variantes de horario generadas:', uniqueVariants);
+
+  return uniqueVariants;
+};
diff --git a/src/features/AppointmentsScheduler/components/PageHeader/PageHeader.tsx b/src/features/AppointmentsScheduler/components/PageHeader/PageHeader.tsx
index ae611b3..dfa2cb4 100644
--- a/src/features/AppointmentsScheduler/components/PageHeader/PageHeader.tsx
+++ b/src/features/AppointmentsScheduler/components/PageHeader/PageHeader.tsx
@@ -16,11 +16,13 @@ const { Title } = Typography;
 type Props = {
   showFilters: boolean;
   handleToggleShowFilters: () => void;
+  onNavigateToFirstAvailable: () => void;
 };
 
 export const PageHeader: React.FC<Props> = ({
   showFilters,
   handleToggleShowFilters,
+  onNavigateToFirstAvailable,
 }) => {
   const firstAvailableDate = useAppointmentsSummaryStore(
     (state) => state?.primerOfertaDisponible
@@ -49,7 +51,10 @@ export const PageHeader: React.FC<Props> = ({
           Selecci√≥n de Turnos
         </Title>
 
-        <FirstAvailableIcon firstAvailableDate={firstAvailableDate} />
+        <FirstAvailableIcon
+          firstAvailableDate={firstAvailableDate}
+          onNavigateToFirstAvailable={onNavigateToFirstAvailable}
+        />
       </div>
 
       {/* Segunda l√≠nea: Filtros aplicados */}
diff --git a/src/features/AppointmentsScheduler/components/PageHeader/components/FirstAvailableIcon/FirstAvailableIcon.module.css b/src/features/AppointmentsScheduler/components/PageHeader/components/FirstAvailableIcon/FirstAvailableIcon.module.css
index 3b761c2..8f99a1c 100644
--- a/src/features/AppointmentsScheduler/components/PageHeader/components/FirstAvailableIcon/FirstAvailableIcon.module.css
+++ b/src/features/AppointmentsScheduler/components/PageHeader/components/FirstAvailableIcon/FirstAvailableIcon.module.css
@@ -1,4 +1,4 @@
-
+/* Contenedor base del √≠cono */
 .icon-container {
   display: inline-flex;
   align-items: center;
@@ -9,13 +9,36 @@
   margin-right: -4px;
   cursor: help;
   border-radius: 4px;
-  transition: background-color 0.3s ease;
+  transition: background-color 0.3s ease, transform 0.2s ease;
 }
 
+/* Estado hover para contenedor base */
 .icon-container:hover {
   background-color: rgba(64, 169, 255, 0.1);
 }
 
+/* Contenedor cuando es clickeable */
+.icon-container-clickable {
+  cursor: pointer;
+}
+
+.icon-container-clickable:hover {
+  background-color: rgba(64, 169, 255, 0.15);
+  transform: scale(1.05);
+}
+
+.icon-container-clickable:active {
+  background-color: rgba(64, 169, 255, 0.2);
+  transform: scale(0.98);
+}
+
+/* Focus visible para accesibilidad */
+.icon-container-clickable:focus-visible {
+  outline: 2px solid #40a9ff;
+  outline-offset: 2px;
+}
+
+/* √çcono base */
 .exclamation-icon {
   font-size: 24px;
   color: #40a9ff !important; 
@@ -27,6 +50,17 @@
   transform: scale(1.1);
 }
 
+/* √çcono cuando es clickeable */
+.exclamation-icon-clickable {
+  color: #1890ff !important;
+}
+
+.exclamation-icon-clickable:hover {
+  color: #096dd9 !important;
+  transform: scale(1.15);
+}
+
+/* Estado de carga */
 .exclamation-icon.loading {
   color: #40a9ff !important;
   animation: pulse 2s infinite;
diff --git a/src/features/AppointmentsScheduler/components/PageHeader/components/FirstAvailableIcon/FirstAvailableIcon.tsx b/src/features/AppointmentsScheduler/components/PageHeader/components/FirstAvailableIcon/FirstAvailableIcon.tsx
index 9ddbc51..e644295 100644
--- a/src/features/AppointmentsScheduler/components/PageHeader/components/FirstAvailableIcon/FirstAvailableIcon.tsx
+++ b/src/features/AppointmentsScheduler/components/PageHeader/components/FirstAvailableIcon/FirstAvailableIcon.tsx
@@ -1,60 +1,77 @@
-import React, { useMemo } from 'react';
+import React from 'react';
 import { Tooltip } from 'antd';
 import { ExclamationCircleFilled } from '@ant-design/icons';
-import {
-  LOCALE_CODE_ES,
-  capitalizeStringChar,
-} from '~/features/AppointmentsScheduler/utils';
+import { useFirstAvailableDateTime } from '~/features/AppointmentsScheduler/hooks/useFirstAvailableDateTime';
 import styles from './FirstAvailableIcon.module.css';
 
 type Props = {
-  firstAvailableDate: string | undefined; // Tipo exacto del store
+  firstAvailableDate: string | undefined; // Mantenemos para compatibilidad
+  onNavigateToFirstAvailable?: () => void; // Nueva prop opcional
 };
 
 /**
- * √çcono que muestra la primera fecha disponible en un tooltip
- * Se ubica al final del PageHeader
+ * √çcono que muestra la primera fecha y hora disponible en un tooltip
+ * Permite navegar al primer turno disponible al hacer clic
  */
-export const FirstAvailableIcon: React.FC<Props> = ({ firstAvailableDate }) => {
-  const loading = !firstAvailableDate;
-  const formattedDate = useMemo(() => {
-    if (!firstAvailableDate) return null;
+export const FirstAvailableIcon: React.FC<Props> = ({
+  firstAvailableDate,
+  onNavigateToFirstAvailable,
+}) => {
+  // Usar el hook unificado para obtener toda la informaci√≥n
+  const { formattedTooltip, hasData } = useFirstAvailableDateTime();
 
-    // Convertir string ISO a Date
-    const dateObject = new Date(firstAvailableDate);
+  // Determinar si est√° cargando basado en ambas fuentes
+  const loading = !firstAvailableDate || !hasData;
 
-    // Verificar que la fecha sea v√°lida
-    if (isNaN(dateObject.getTime())) return null;
+  // Determinar si es clickeable
+  const isClickable = Boolean(hasData && onNavigateToFirstAvailable);
 
-    const fullDate = dateObject.toLocaleDateString(LOCALE_CODE_ES, {
-      weekday: 'long',
-      day: 'numeric',
-      month: 'long',
-      year: 'numeric',
-    });
+  const handleClick = () => {
+    if (isClickable) {
+      onNavigateToFirstAvailable?.();
+    }
+  };
 
-    return capitalizeStringChar(0, fullDate);
-  }, [firstAvailableDate]);
+  // Determinar el cursor y eventos apropiados
+  const interactionProps = isClickable
+    ? {
+        onClick: handleClick,
+        role: 'button' as const,
+        tabIndex: 0,
+        'aria-label': 'Navegar al primer turno disponible',
+        style: { cursor: 'pointer' },
+      }
+    : {
+        'aria-label': 'Primer turno disponible',
+        style: { cursor: loading ? 'default' : 'help' },
+      };
 
-  const tooltipContent = useMemo(() => {
-    if (loading) return 'Cargando primera fecha disponible...';
-    if (!formattedDate) return 'No hay fechas disponibles';
-    return `Primer turno disponible: ${formattedDate}`;
-  }, [loading, formattedDate]);
+  // Manejar Enter/Space para accesibilidad
+  const handleKeyDown = (event: React.KeyboardEvent) => {
+    if (isClickable && (event.key === 'Enter' || event.key === ' ')) {
+      event.preventDefault();
+      handleClick();
+    }
+  };
 
   return (
     <Tooltip
-      title={tooltipContent}
+      title={formattedTooltip}
       placement="bottom"
       mouseEnterDelay={0.3}
       mouseLeaveDelay={0}
     >
       <div
-        className={styles['icon-container']}
-        aria-label="Primer turno disponible"
+        className={`${styles['icon-container']} ${
+          isClickable ? styles['icon-container-clickable'] : ''
+        }`}
+        {...interactionProps}
+        onKeyDown={isClickable ? handleKeyDown : undefined}
       >
         <ExclamationCircleFilled
-          className={`${styles['exclamation-icon']} ${loading ? styles['loading'] : ''}`}
+          className={`${styles['exclamation-icon']} ${
+            loading ? styles['loading'] : ''
+          } ${isClickable ? styles['exclamation-icon-clickable'] : ''}`}
         />
       </div>
     </Tooltip>
diff --git a/src/features/AppointmentsScheduler/hooks/index.ts b/src/features/AppointmentsScheduler/hooks/index.ts
index a554b71..1960622 100644
--- a/src/features/AppointmentsScheduler/hooks/index.ts
+++ b/src/features/AppointmentsScheduler/hooks/index.ts
@@ -4,8 +4,8 @@ export { useIsTurnosCombo } from './useIsTurnosCombo';
 export { useAppliedFilterPracticeTurnosReserva } from './useAppliedFilterPracticeTurnosReserva';
 export { useFirstAvailableAppointmentsSummaryData } from './useFirstAvailableSummaryAppointmentsData';
 export { useSchedulerMonthDateRangeFromList } from './useSchedulerMonthDateRangeFromList';
-export { useFirstAvailableDate } from './useFirstAvailableDate';
 export { useEquipmentPlacesFilter } from './useEquipmentPlacesFilter';
 export { usePatientPlacesFilter } from './usePatientPlacesFilter';
 export { useAppliedEquipmentPlacesFilter } from './useAppliedEquipmentPlacesFilter';
 export { useAppliedPatientPlacesFilter } from './useAppliedPatientPlacesFilter';
+export { useFirstAvailableDateTime } from './useFirstAvailableDateTime';
diff --git a/src/features/AppointmentsScheduler/hooks/useFirstAvailableDate.tsx b/src/features/AppointmentsScheduler/hooks/useFirstAvailableDate.tsx
deleted file mode 100644
index 503ed30..0000000
--- a/src/features/AppointmentsScheduler/hooks/useFirstAvailableDate.tsx
+++ /dev/null
@@ -1,28 +0,0 @@
-import { useMemo } from 'react';
-import { useAppointmentsSummaryStore } from '~/features/AppointmentsScheduler/store';
-
-/**
- * Hook para obtener la primera fecha disponible desde el store
- * Usa el campo `primerOfertaDisponible` de la respuesta del backend
- */
-export const useFirstAvailableDate = () => {
-  const primerOfertaDisponible = useAppointmentsSummaryStore(
-    (state) => state?.primerOfertaDisponible
-  );
-
-  const firstAvailableDate = useMemo(() => {
-    if (!primerOfertaDisponible) return null;
-
-    try {
-      return new Date(primerOfertaDisponible);
-    } catch (error) {
-      console.warn('Error parsing primerOfertaDisponible:', error);
-      return null;
-    }
-  }, [primerOfertaDisponible]);
-
-  return {
-    firstAvailableDate,
-    isLoading: !primerOfertaDisponible, // Si no hay dato, asumimos que est√° cargando
-  };
-};
diff --git a/src/features/AppointmentsScheduler/hooks/useFirstAvailableDateTime.ts b/src/features/AppointmentsScheduler/hooks/useFirstAvailableDateTime.ts
new file mode 100644
index 0000000..f0b4593
--- /dev/null
+++ b/src/features/AppointmentsScheduler/hooks/useFirstAvailableDateTime.ts
@@ -0,0 +1,79 @@
+import { useMemo } from 'react';
+import { useAppointmentsSummaryStore } from '~/features/AppointmentsScheduler/store';
+import { WORK_START_TIME } from '../components/KendoSchedulerView/utils';
+import { normalizeTimeToSchedulerSlot } from '../components/KendoSchedulerView/utils/timeSlotNormalizer';
+
+/**
+ * Hook unificado para obtener fecha y hora del primer turno disponible
+ * Proporciona m√∫ltiples formatos para diferentes usos en la UI
+ * Incluye normalizaci√≥n de horarios para compatibilidad con scheduler
+ */
+export const useFirstAvailableDateTime = () => {
+  const primerOfertaDisponible = useAppointmentsSummaryStore(
+    (state) => state?.primerOfertaDisponible
+  );
+
+  return useMemo(() => {
+    if (!primerOfertaDisponible) {
+      return {
+        fullDateTime: null,
+        dateObject: null,
+        shortDate: null,
+        timeSlot: WORK_START_TIME, // Para scroll (normalizado)
+        originalTimeSlot: null, // Horario original del backend
+        formattedTooltip: 'Cargando primer turno disponible...',
+        hasData: false,
+      };
+    }
+
+    try {
+      const dateObject = new Date(primerOfertaDisponible);
+
+      if (isNaN(dateObject.getTime())) {
+        throw new Error('Invalid date');
+      }
+
+      // Formato de fecha corto (dd/mm/yyyy)
+      const shortDate = dateObject.toLocaleDateString('es-ES', {
+        day: '2-digit',
+        month: '2-digit',
+        year: 'numeric',
+      });
+
+      // Horario original espec√≠fico (HH:MM)
+      const originalTimeSlot = dateObject.toLocaleTimeString('es-ES', {
+        hour: '2-digit',
+        minute: '2-digit',
+        hour12: false,
+      });
+
+      // Horario normalizado para el scheduler (slots de 1 hora)
+      const normalizedTimeSlot = normalizeTimeToSchedulerSlot(originalTimeSlot);
+
+      // Tooltip seg√∫n especificaci√≥n exacta del ticket
+      const formattedTooltip = `El d√≠a ${shortDate} a la hora ${originalTimeSlot} tiene el primer turno disponible`;
+
+      return {
+        fullDateTime: primerOfertaDisponible,
+        dateObject,
+        shortDate,
+        timeSlot: normalizedTimeSlot, // Para scroll (normalizado)
+        originalTimeSlot, // Para mostrar en tooltip
+        formattedTooltip,
+        hasData: true,
+      };
+    } catch (error) {
+      console.warn('Error parsing primerOfertaDisponible:', error);
+
+      return {
+        fullDateTime: null,
+        dateObject: null,
+        shortDate: null,
+        timeSlot: WORK_START_TIME,
+        originalTimeSlot: null,
+        formattedTooltip: 'Error al cargar primer turno disponible',
+        hasData: false,
+      };
+    }
+  }, [primerOfertaDisponible]);
+};
